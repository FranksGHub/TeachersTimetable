Dart naming conventions:
Element 	Schreibweise	  Beispiel
Datei	    snake_case	    settings_page.dart
Klasse	  PascalCase	    SettingsPage
Methode	  lowerCamelCase	loadSettings()
Parameter	lowerCamelCase	newValue
Variable	lowerCamelCase	userName
Enum	    PascalCase	    UserRole
Konstante lowerCamelCase  maxRetries = 3;
    oder  Caps_with_Unde. MAX_RETRIES = 3;
All private elements starting with'_':  _lowerCamelCase _onChanged()


Version 1.1.0
Step 1
We already have the 6 rows with 5 blocks each. Now, when we click on a block, a settings dialog will open and we can edit the color, the lesson name, the class name and the school name. In the next step, if we click on a block, another page should be open (or a popup dialog) with a settings button on the top right corner, which will open the current settings dialog with the color, lesson name and so on. Inside the new page, we need two lists with text line items and text line subitems wich can be filled by the user (default is an empty list), items can be collapsed and expand again. There must be a button to add an item and a button to add an subitem to an selected item. The list on the right side is loaded from and saved to a jason file, the filename is the lesson name of the block combines with ".json". The left side list is loaded from and saved to a json file with filename combined by the lesson name and the school name of the block added with ".json". The path of all the files can be set inside the main hamburger menu and should be stored inside the prefs. The text line items in the left side list needs a status button and a status text on the left side of each text line with the states "Planned", "Working" and "Finished". The belonging status texts are "P", "W" and "F". Default is "Planned" and each click on the status button will switch the status text to the next status and back to "Planned". One more global button is needed to copy a text line item selected in the right side list into the left side list, above the left lists selected position or at the end of the list if no item is selected on the left side. Also there must be a button to copy a sub item from the right side list into a selected item on the left side list. Also the items and subitems on the left side list may be moved one row to the top, or one row to the button of the list. The subitems stay inside the item, if the item is moved. The sub items may be moved inside the parent item only.

Step 2
There is an exception, if i add subitems to an item: "UnsupportedError (Unsupported operation: Cannot add to an unmodifiable list)" in line 136 of the file lesson_detail_page.dart.
The text of each item and subitem must be editable by the user, with another click on a selected item / sub item or a double click or a separate button...

Step 3
The status button and text of the left list must be located at the subitem. Insert a space between the status text and the sub item text. Let the button color be green if the status is finished and otherwise yellow. The default after loading the list on the left side should be collapsed if all subitems of a item are on green and otherwise expanded. On the right side list, after loading, all items must be collapsed. Please move the copy buttons to the right list and make all the button and page strings translatable. Thank you!

Step 4
Please add a delete button to each line of the left and right list items. Good position is on the left side of the move up and down buttons. The right list is missing the up and down buttons at the item lines, only the sub item have this buttons. The current selected line is not realy visible in all cases, can we paint the selected line with a light gray background?

Web Version?
In the web version, I can't execute "setDataPath," and the edit_block_dialog doesn't close when I save. The settings are saved somewhere, but only for this browser. In another browser, the settings are gone. Where can the user settings be saved in the web version? Is that even possible in the web version? How does it work in the Android version?
Answer: "Since localStorage is browser-specific, consider:  
Cloud Sync (best solution):
            Add Firebase Firestore or similar backend
            Users can sync data across browsers and devices
Export/Import (current approach):
            Your app already has this! The user can export and import data
Use isar or hive package (local database):
            Better than SharedPreferences for web
            Still browser-specific, but more reliable

Android version?
On Android I choose a sub path from Documents for the data path, but automatic load / save for the both lists in lesson_detail_page.dart is not possible. Manuell export / import of the user settings data is possible.

~~~~~~~~~~~~~~~~~~~~~~~~~~
https://developer.android.com/training/data-storage/manage-all-files?hl=de
Zugriff auf alle Dateien anfordern
Eine App kann den Zugriff auf alle Dateien vom Nutzer anfordern, indem sie Folgendes tut:

Deklarieren Sie die Berechtigung MANAGE_EXTERNAL_STORAGE im Manifest.
Verwende die Intent-Aktion ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION, um Nutzer zu einer Seite mit Systemeinstellungen weiterzuleiten, auf der sie die folgende Option f√ºr deine App aktivieren k√∂nnen: Zugriff zum Verwalten aller Dateien zulassen.
Rufen Sie Environment.isExternalStorageManager() auf, um festzustellen, ob Ihrer App die Berechtigung MANAGE_EXTERNAL_STORAGE erteilt wurde.

Die Berechtigung MANAGE_EXTERNAL_STORAGE gew√§hrt Folgendes:

Lese- und Schreibzugriff auf alle Dateien im gemeinsamen Speicher.

Hinweis :Das Verzeichnis /sdcard/Android/media‚Å† ist Teil des gemeinsam genutzten Speichers.
Zugriff auf die Inhalte der Tabelle MediaStore.Files.

Zugriff auf das Stammverzeichnis des USB-OTG-Laufwerks und der SD-Karte.

Schreibzugriff auf alle internen Speicherverzeichnisse mit Ausnahme von /Android/data/, /sdcard/Android und den meisten Unterverzeichnissen von /sdcard/Android. Dieser Schreibzugriff umfasst den Zugriff √ºber den direkten Dateipfad.

Apps, denen diese Berechtigung erteilt wurde, k√∂nnen weiterhin nicht auf die app-spezifischen Verzeichnisse anderer Apps zugreifen, da diese Verzeichnisse als Unterverzeichnisse von Android/data/ auf einem Speichermedium angezeigt werden.

Wenn eine App die Berechtigung MANAGE_EXTERNAL_STORAGE hat, kann sie √ºber die MediaStore API oder direkte Dateipfade auf diese zus√§tzlichen Dateien und Verzeichnisse zugreifen. Wenn Sie jedoch das Storage Access Framework verwenden, k√∂nnen Sie nur dann auf eine Datei oder ein Verzeichnis zugreifen, wenn Sie dies ohne die Berechtigung MANAGE_EXTERNAL_STORAGE tun k√∂nnen.

~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://developer.android.com/training/data-storage/app-specific?hl=de#internal-access-files
Auf app-spezifische Dateien zugreifen



In vielen F√§llen erstellt Ihre App Dateien, auf die andere Apps nicht zugreifen m√ºssen oder sollten. Das System bietet die folgenden Speicherorte zum Speichern solcher app-spezifischen Dateien:

Verzeichnisse f√ºr internen Speicher:Diese Verzeichnisse umfassen sowohl einen dedizierten Speicherort f√ºr persistente Dateien als auch einen weiteren Speicherort f√ºr Cache-Daten. Das System verhindert, dass andere Apps auf diese Speicherorte zugreifen. Unter Android 10 (API‚ÄëLevel 29) und h√∂her werden diese Speicherorte verschl√ºsselt. Aufgrund dieser Eigenschaften eignen sich diese Speicherorte gut zum Speichern vertraulicher Daten, auf die nur Ihre App selbst zugreifen kann.

Externe Speicherverzeichnisse:Diese Verzeichnisse enthalten sowohl einen dedizierten Speicherort f√ºr persistente Dateien als auch einen weiteren Speicherort f√ºr Cache-Daten. Obwohl eine andere App mit den entsprechenden Berechtigungen auf diese Verzeichnisse zugreifen kann, sind die darin gespeicherten Dateien nur f√ºr die Verwendung durch Ihre App vorgesehen. Wenn Sie Dateien erstellen m√∂chten, auf die andere Apps zugreifen k√∂nnen, sollte Ihre App diese Dateien stattdessen im gemeinsamen Speicher des externen Speichers speichern.

Wenn der Nutzer Ihre App deinstalliert, werden die im App-spezifischen Speicher gespeicherten Dateien entfernt. Aus diesem Grund sollten Sie diesen Speicher nicht verwenden, um Inhalte zu speichern, die der Nutzer unabh√§ngig von Ihrer App behalten m√∂chte. Wenn Ihre App beispielsweise Nutzern erm√∂glicht, Fotos aufzunehmen, erwarten sie, dass sie auch nach der Deinstallation Ihrer App auf diese Fotos zugreifen k√∂nnen. Daher sollten Sie stattdessen den freigegebenen Speicher verwenden, um diese Arten von Dateien in der entsprechenden Mediensammlung zu speichern.

In den folgenden Abschnitten wird beschrieben, wie Sie Dateien in appspezifischen Verzeichnissen speichern und darauf zugreifen.
Zugriff √ºber den internen Speicher
F√ºr jede App stellt das System Verzeichnisse im internen Speicher bereit, in denen eine App ihre Dateien organisieren kann. Ein Verzeichnis ist f√ºr die persistenten Dateien Ihrer App vorgesehen, das andere enth√§lt die im Cache gespeicherten Dateien Ihrer App. Ihre App ben√∂tigt keine Systemberechtigungen, um Dateien in diesen Verzeichnissen zu lesen und zu schreiben.

Andere Apps k√∂nnen nicht auf Dateien zugreifen, die im internen Speicher abgelegt sind. Daher ist der interne Speicher ein guter Ort f√ºr App-Daten, auf die andere Apps nicht zugreifen sollten.

Diese Verzeichnisse sind jedoch in der Regel klein. Bevor Ihre App app-spezifische Dateien in den internen Speicher schreibt, sollte sie den freien Speicherplatz auf dem Ger√§t abfragen.

Auf persistente Dateien zugreifen
Die normalen, persistenten Dateien Ihrer App befinden sich in einem Verzeichnis, auf das Sie mit dem Attribut filesDir eines Kontextobjekts zugreifen k√∂nnen. Das Framework bietet mehrere Methoden, mit denen Sie auf Dateien in diesem Verzeichnis zugreifen und sie dort speichern k√∂nnen.

Auf Dateien zugreifen und Dateien speichern
Sie k√∂nnen die File API verwenden, um auf Dateien zuzugreifen und sie zu speichern.

Um die Leistung Ihrer App zu erhalten, sollten Sie dieselbe Datei nicht mehrmals √∂ffnen und schlie√üen.

Das folgende Code-Snippet zeigt, wie die File API verwendet wird:

Kotlin
Java

val file = File(context.filesDir, filename)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://stackoverflow.com/questions/78692611/file-permission-for-android-14-and-higher

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step 5
Let's forget about freely choosing a directory for file storage. Instead, let's use the shared directory for Android apps via "getApplicationDocumentsDirectory". On Windows, files can also be automatically stored and read in the AppData directory with the program name.

Step 6
My only problem now is that I can no longer copy files between Android and Windows. I need two menu items in the hamburger menu: "Export all files" and "Import all files." Ideally, a zip file should be able to be saved and read there. The zip file should contain all files in the dataPath directory, and when imported, the zip should be extracted back into that directory. Existing files will be overwritten in the process.

Step 7
Just one more small thing: the line spacing in the two lists of `lesson_details_page.dart` is too large; it could be halved. This applies to both the items and the sub-items. A separator line appears between the items; this could also be removed.


Step 8 printing
Ich m√∂chte aus meiner flutter / dart app ein pdf zum Drucker schicken. Die Seite besteht aus einer √úberschrift, einer Tabelle aus 5 Spalten mit 6 Zeilen die jeweils einen farbigen Block mit 3 Zeilen Text enthalten. √úber den Spalten gibt es jeweils einen zentrierten Text und links von den Zeilen gibt es ebenfalls einen Text. Die Infos f√ºr die √úberschrift kommt aus dem "title" parameter, die Texte oberhalb der Spalten aus dem "days" parameter, die Texte vor den Zeilen aus dem "times" parameter und die Block Infos aus dem "LessonBlock" parameter. Lesson Block hat variablen f√ºr Color und 3 Strings f√ºr die Textzeilen. Anfangen w√ºrde ich mit: "  Future<bool> PrintTimetable(BuildContext context, String title, List<String> days, List<String> times, List<List<LessonBlock>> timetable) async {    final pdf = pw.Document();    pdf.addPage(" 


Step 9 Menu change in lesson_datail_page
The file lesson_datail_page.dart contains four buttons for printing, showing/hiding the two lists, and accessing settings. These buttons should be moved to a menu that looks and feels like the drawer menu in the page timetable_page.dart. The icons should be copied to the menu.


Step save on close
Kann ich bei einer flutter Seite feststellen, wenn die Seite geschlossen werden soll und vorher noch die Daten sichern?

onPopInvokedWithResult
Damit bist du zukunftssicher und kompatibel mit:

Android Predictive Back

Windows/macOS/Linux Fenster‚ÄëSchlie√üen

Navigator.pop()

AppBar‚ÄëBack‚ÄëButton

Ich zeige dir jetzt die korrekte, moderne L√∂sung, die zuverl√§ssig deine Daten speichert, bevor die Seite geschlossen wird.

üéØ 1. PopScope mit onPopInvokedWithResult (neue API)
So sieht die empfohlene Implementierung aus:
return PopScope(
  canPop: true,
  onPopInvokedWithResult: (didPop, result) async {
    // Egal ob die Seite wirklich geschlossen wurde oder nicht:
    await saveData();
  },
  child: Scaffold(
    appBar: AppBar(title: Text("Notizen")),
    body: ...
  ),
);
Was passiert hier?
didPop == true ‚Üí Seite wurde bereits geschlossen
didPop == false ‚Üí Nutzer wollte schlie√üen, aber Navigation hat es verhindert
in beiden F√§llen speicherst du sicher

2. Windows/macOS/Linux: Fenster‚ÄëSchlie√üen abfangen
PopScope reagiert NICHT, wenn der Nutzer das Fenster √ºber das X schlie√üt.

Daf√ºr brauchst du:

WidgetsBindingObserver
class NotesPageState extends State<NotesPage> with WidgetsBindingObserver {

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    saveData(); // Sicherheitshalber
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.detached ||
        state == AppLifecycleState.inactive) {
      saveData();
    }
  }
}

3. F√ºr alle Plattformen kombiniert
class NotesPage extends StatefulWidget {
  @override
  State<NotesPage> createState() => _NotesPageState();
}

class _NotesPageState extends State<NotesPage> with WidgetsBindingObserver {

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    saveData();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.detached ||
        state == AppLifecycleState.inactive) {
      saveData();
    }
  }

  Future<void> saveData() async {
    // deine Speicherlogik
  }

  @override
  Widget build(BuildContext context) {
    return PopScope(
      canPop: true,
      onPopInvokedWithResult: (didPop, result) async {
        await saveData();
      },
      child: Scaffold(
        appBar: AppBar(title: Text("Notizen")),
        body: ...
      ),
    );
  }
}

Step Kann ich erkennen, ob die flutter_quill Text Daten ge√§ndert wurden?
1. √Ñnderungen erkennen √ºber controller.document.changes (empfohlen)
Der QuillController besitzt einen Stream, der jedes Delta‚ÄëUpdate liefert.
Damit erkennst du jede Text√§nderung, egal ob Tippen, L√∂schen, Einf√ºgen, Undo, Redo.

bool hasChanged = false;

@override
void initState() {
  super.initState();

  controllerQuill = QuillController.basic();

  controllerQuill.document.changes.listen((event) {
    if (event.item3 == ChangeSource.LOCAL) {
      hasChanged = true;
    }
  });
}

Future<void> saveIfNeeded() async {
  if (hasChanged) {
    await saveData();
    hasChanged = false;
  }
}

@override
Widget build(BuildContext context) {
  return PopScope(
    canPop: true,
    onPopInvokedWithResult: (didPop, result) async {
      await saveIfNeeded();
    },
    child: Scaffold(
      appBar: AppBar(title: Text("Notizen")),
      body: QuillEditor.basic(
        controller: controllerQuill,
        readOnly: false,
      ),
    ),
  );
}


Frank, jetzt haben wir den entscheidenden Punkt gefunden:
In deiner Version von flutter_quill (11.x) wird weder controller.document.changes noch controller.changes ausgel√∂st, solange du den Controller vor dem Laden der Daten initialisierst.

Das ist ein bekanntes Verhalten in Quill 10‚Äì11:
üëâ Wenn du den Controller mit QuillController.basic() erstellst und danach das Dokument ersetzt, feuern keine Events.

‚Üí Der Listener h√§ngt noch am alten Controller  
‚Üí Der neue Controller hat keinen Listener  
‚Üí Es kommt nie ein Event

Controller in loadPrefsAndData() erstellen und erst dann Listener setzen
Future<void> loadPrefsAndData() async {
  final delta = await loadDeltaFromJson(); // dein gespeicherter Text

  controllerQuill = quill.QuillController(
    document: quill.Document.fromDelta(delta),
    selection: const TextSelection.collapsed(offset: 0),
  );

  // üî• Listener HIER setzen ‚Äì nicht vorher!
  controllerQuill.changes.listen((event) {
    if (event.source == quill.ChangeSource.local) {
      hasNoteChanges = true;
      print("Quill wurde ge√§ndert");
    }
  });

  setState(() {});
}

üü¶ Alternative: Wenn du unbedingt basic() nutzen willst
Dann musst du das Dokument in den bestehenden Controller einf√ºgen, statt den Controller zu ersetzen:
controllerQuill = quill.QuillController.basic();

controllerQuill.document.replace(
  0,
  controllerQuill.document.length,
  loadedDelta,
);



‚≠ê Bonus: Nur echte Text√§nderungen z√§hlen
controllerQuill.changes.listen((event) {
  if (event.source == quill.ChangeSource.local &&
      event.change.isNotEmpty) {
    hasNoteChanges = true;
  }
});
